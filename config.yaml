# ===== Вхід / Вихід =====

# Шлях до папки із зображеннями. Може містити підпапки --
# скрипт рекурсивно знайде всі зображення і об'єднає в один пул.
input_dir: "D:/datasets_images/dataset"

# Шлях куди будуть розкладені зображення по папках пресетів.
# Створюється автоматично. Всередині: preset_000/, preset_001/, ...
output_dir: "D:/dataset_filtered_by_presets"

# Режим переміщення файлів:
#   "copy" -- копіює (оригінали залишаються на місці)
#   "move" -- переміщує (оригінали видаляються зі старого місця)
mode: "copy"

# Які розширення файлів вважати зображеннями (регістр ігнорується).
image_extensions: [".jpg", ".jpeg", ".png", ".bmp", ".tiff"]

# ===== Модель для витягування ознак =====

model:
  # Яку нейронну мережу використовувати для отримання вектора ознак:
  #   "dinov2_vits14" -- DINOv2 ViT-Small (384-dim вектор, швидка)
  #   "dinov2_vitb14" -- DINOv2 ViT-Base  (768-dim вектор, точніша, рекомендована для 4090)
  #   "resnet50"      -- ResNet50 pretrained на ImageNet (2048-dim, найлегша)
  name: "dinov2_vitb14"

  # Кількість зображень в одному батчі при inference.
  # Більше = швидше, але потребує більше VRAM.
  # RTX 4090 24GB: ViT-B@518 -> batch_size 48-64. ViT-S@518 -> 128-256.
  batch_size: 64

  # Розмір зображення (в пікселях) при подачі в модель.
  # DINOv2 працює з будь-яким розміром кратним 14, але 224 -- стандарт.
  # 518 (37*14) -- нативна роздільна здатність DINOv2 (найкращі ознаки).
  # 448 (32*14) -- компроміс. RTX 4090 легко тягне 518.
  image_size: 518

  # Пристрій для обчислень:
  #   "auto" -- автоматично GPU якщо є, інакше CPU
  #   "cuda" -- примусово GPU (впаде з помилкою якщо немає)
  #   "cpu"  -- примусово CPU (повільно, але завжди працює)
  device: "cuda"

  # Кількість CPU-процесів для паралельного препроцесингу зображень
  # (завантаження, trim, CLAHE, transform). Поки GPU обробляє поточний батч,
  # воркери готують наступний. 0 -- без паралелізму (все в main thread).
  # 4-8 -- рекомендовано. Більше ядер CPU -- більше воркерів можна.
  num_workers: 8

  # Скільки батчів кожен воркер готує наперед.
  # 2 -- стандарт. Більше -- більше RAM, але GPU менше простоює.
  # Працює тільки при num_workers > 0.
  prefetch_factor: 4

  # Закріплення пам'яті (pinned memory) для швидшого CPU → GPU трансферу.
  # true -- рекомендовано при використанні GPU. Трохи більше RAM.
  # false -- якщо мало оперативної пам'яті або device: "cpu".
  pin_memory: true

# ===== Препроцесинг зображень =====
# Критично важливо для тепловізійних камер!
# Без нормалізації модель "бачить" різницю в яскравості/температурі
# і розділяє один пресет на кілька кластерів (день/ніч, тепло/холодно).

preprocessing:
  # Метод еквалізації гістограми для нормалізації контрасту:
  #   "he"   -- глобальна гістограмна еквалізація (cv2.equalizeHist).
  #             Має математичну властивість HE(255-X) = 255-HE(X),
  #             тобто ідеально симетрична при інверсії полярності.
  #             Рекомендовано для тепловізорів з polarity_invariant: true.
  #   "clahe" -- CLAHE (локальна адаптивна еквалізація).
  #             Кращий локальний контраст, але НЕ симетрична при інверсії:
  #             CLAHE(255-X) ≠ 255-CLAHE(X). Рекомендовано без dual-pass.
  #   "none" -- без еквалізації. Для звичайних RGB-камер.
  equalization: "he"

  # Параметри CLAHE (використовуються тільки при equalization: "clahe"):
  # Обмеження контрасту. 1.0-2.0 -- слабке, 3.0-5.0 -- агресивне.
  clahe_clip_limit: 3.0
  # Розмір сітки для локальної нормалізації. 8 -- стандарт.
  clahe_grid_size: 8

  # Інваріантність до полярності тепловізора (dual-pass).
  # Для кожного зображення витягує ознаки з ОРИГІНАЛУ і з ІНВЕРТОВАНОЇ копії,
  # потім усереднює. Математично гарантує: f(img) == f(255-img).c
  # Тобто white-hot і black-hot зображення одного пресету дають схожий
  # вектор ознак. Подвоює час витягування
  # true -- рекомендовано для тепловізійних камер, де використовувалося dual-pass
  polarity_invariant: true

  # L2-нормалізація вектора ознак після витягування.
  # Прибирає вплив загальної "магнітуди" вектора (яка корелює з яскравістю).
  # Фокусує кластеризацію на напрямку вектора (= структура сцени).
  # true -- рекомендовано завжди.
  l2_normalize: true

  # Обрізка країв зображення перед витягуванням ознак (у відсотках, 0.0–1.0).
  # Прибирає OSD (On Screen Display) — дату, час, назву камери тощо,
  # які зазвичай розташовані по краях кадру. Без обрізки OSD може впливати
  # на ознаки і створювати хибні кластери.
  # Наприклад, trim_top: 0.05 обріже верхні 5% зображення.
  # 0.0 -- без обрізки.
  trim_top: 0.1
  trim_bottom: 0.1
  trim_left: 0.01
  trim_right: 0.01

# ===== Зменшення розмірності =====

reduction:
  # PCA: перший етап зменшення (лінійний, швидкий).
  # Зменшує вектор з 384/768/2048 dim до цього числа.
  # Прибирає шум та корельовані ознаки.
  # Для ViT-B (768-dim) краще 100, для ViT-S (384-dim) -- 50.
  pca_components: 100

  # UMAP: другий етап зменшення (нелінійний, зберігає структуру).
  # Зменшує з pca_components до цього числа для кластеризації.
  # 5-8 добре працює для HDBSCAN (менше = чистіші кластери).
  # 10+ може розмити межі між схожими пресетами.
  umap_components: 5

  # Кількість сусідів для UMAP. Впливає на баланс локальна/глобальна структура.
  # Менше (5-10) -- більше локальних деталей, групи щільніші.
  # Більше (30-50) -- більше глобальної структури, кращий поділ пресетів.
  # 30 -- рекомендовано для задачі пресетів (глобальна структура важливіша).
  umap_n_neighbors: 30

  # Мінімальна відстань між точками в UMAP-просторі.
  # 0.0 -- максимально щільні кластери (найкраще для HDBSCAN).
  # 0.1 -- трохи розпушені. Для кластеризації краще 0.0.
  umap_min_dist: 0.0

  # Метрика відстані для UMAP:
  #   "cosine"    -- косинусна подібність (рекомендована для NN-ознак)
  #   "euclidean" -- евклідова відстань
  umap_metric: "cosine"

# ===== Кластеризація =====

clustering:
  # Мінімальна кількість зображень для формування одного пресета (кластера).
  # Якщо менше цього числа -- вважається шумом.
  # Для датасету 10K-100K: 50-200 залежно від кількості знімків на пресет.
  # Якщо пресети мають мало знімків -- зменшити. Якщо багато -- збільшити.
  min_cluster_size: 100

  # Кількість сусідів для оцінки щільності точки.
  # Більше = консервативніша кластеризація (менше дрібних кластерів, більше шуму).
  # Менше = агресивніша (більше кластерів, деякі можуть бути неякісними).
  # Зазвичай <= min_cluster_size. 5 -- для тепловізійних пресетів.
  min_samples: 5

  # Порогова відстань для злиття кластерів.
  # 0.0 -- кластери не зливаються (стандартна поведінка HDBSCAN).
  # > 0 -- кластери ближчі за цю відстань зливаються в один.
  # 0.3-0.5 -- допомагає злити пресети що розбились на під-кластери
  #            (напр. день/ніч одного й того ж куту огляду).
  cluster_selection_epsilon: 0.5

  # Метод вибору кластерів у HDBSCAN:
  #   "eom"  -- Excess of Mass (стандарт). Може створювати кластери різного розміру.
  #             Іноді "перерозбиває" -- один пресет стає 2-3 кластерами.
  #   "leaf" -- Листкові кластери. Більш однорідні за розміром.
  #             Краще для задачі пресетів, де кожен пресет -- окрема група.
  cluster_selection_method: "leaf"

  # Що робити зі зображеннями, які не потрапили в жоден кластер (шум):
  #   "separate" -- складає в окрему папку "noise/"
  #   "nearest"  -- призначає до найближчого кластера за відстанню
  noise_handling: "nearest"

# ===== Візуалізація =====

visualization:
  # Чи створювати візуалізації після кластеризації.
  enabled: true

  # Папка для збереження файлів візуалізації (відносно output_dir).
  # Всередині: interactive_scatter.html, cluster_grid.png, cluster_sizes.png
  viz_dir: "viz"

  # Максимальна кількість точок на інтерактивному scatter-графіку.
  # Для датасетів > цього числа робиться випадкова вибірка.
  # Менше = швидше завантаження HTML. 5000 -- комфортно в браузері.
  max_points: 500

  # Розмір мініатюри (пікселі) для hover-превью на scatter-графіку.
  # Менше = легший HTML файл. 64-96 -- достатньо для перегляду.
  thumbnail_size: 96

  # Кількість зразків зображень на кластер для статичної сітки.
  # Чим більше -- тим більший файл cluster_grid.png.
  samples_per_cluster: 32

  # Кількість зразків для порівняння CLAHE (до/після).
  # Береться по одному з різних кластерів для різноманітності.
  clahe_comparison_samples: 64

# ===== Валідація чистоти кластерів =====
purity:
  # Чи виконувати автоматичну валідацію чистоти (ізоляції пресетів).
  enabled: true

  # Якщо true і критерії не пройдені, пайплайн зупиниться до розкладання файлів.
  fail_on_fail: true

  # Верхня межа косинусної подібності між центроїдами різних кластерів.
  max_centroid_cosine: 0.92

  # Нижня межа середнього silhouette score в UMAP-просторі.
  min_silhouette: 0.25

  # Верхня межа міжкластерного перетоку (частка kNN з інших кластерів).
  max_nn_cross_ratio: 0.5

  # Кількість сусідів для оцінки міжкластерного перетоку.
  k_neighbors: 5

# ===== Анотації (YOLO) =====

annotations:
  # Чи переносити YOLO-анотації разом із зображеннями.
  # true -- шукає відповідний .txt файл у папці lab/ і переносить.
  # false -- переносить тільки зображення (плоска структура preset_NNN/).
  enabled: true

  # Назва підпапки з зображеннями у вхідних даних.
  # Скрипт шукає цю папку в шляху зображення для заміни на label_subdir.
  image_subdir: "img"

  # Назва підпапки з анотаціями у вхідних даних.
  label_subdir: "lab"

  # Розширення файлів анотацій.
  label_extension: ".txt"

# ===== Кешування =====

cache:
  # Чи зберігати витягнуті ознаки на диск.
  # true -- при повторному запуску з іншими параметрами кластеризації
  #         пропускає найдовший етап (витягування ознак).
  # false -- завжди витягує заново.
  enabled: true

  # Папка для збереження кешу (відносно робочої директорії).
  cache_dir: ".cache"
